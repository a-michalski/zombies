# Cursor Rules - AI-Augmented Engineering

## Core Workflow

### NEVER Code Immediately - Always Plan First

1. **Scan codebase first**

   - Find ALL relevant files

   - List them for user review

   - Wait for approval before coding

   - DO NOT guess - show your reasoning

2. **Ask clarifying questions** in this format:

   ```

   1. [Question about requirements]

      a. [Option A]

      b. [Option B]

   2. [Technical question]

      a. [Technical option A]

      b. [Technical option B]

   ```

3. **Create detailed plan** with:

   - Clear phases with unique IDs

   - Scope boundaries

   - Implementation approach

   - Save in `./docs/plans/` (if exists)

4. **Get explicit approval** before implementation

5. **Work on single phases** - One task at a time

6. **Request code review** after completion

## Code Quality Standards

### Before Writing Code

- Check existing components - reuse before creating new

- Scan design system for similar components

- Follow existing patterns and architecture

- Use relevant documentation as context

### Code Requirements

- TypeScript interfaces for validation

- Proper error handling (no application crashes)

- Comments explaining complex logic

- Semantic variable and function names

- Files under 500 lines (refactor if larger)

- Client and server-side validation

### Pre-Deployment Checklist

✅ Linter passes (BLOCK deployment if fails)

✅ TypeScript errors resolved

✅ Build successful: `npm run build && npm start`

✅ Tested locally

✅ All components render correctly

## Documentation

### Auto-Document After Changes

Add file-level comments with context:

```typescript

/**

 * [Brief description of what file does]

 * 

 * Recent changes (2024-01-15):

 * - [What changed and why]

 * 

 * Next agent: [Important context for next AI or developer]

 */

```

### Documentation Rules

- Save plans: `./docs/plans/` (if structure exists)

- Save docs: `./docs/<area>/` (if structure exists)

- Include working code examples

- Explain the "why" behind decisions

- Reference external docs and URLs

- Update after introducing changes

## Git Workflow

### Branch Management

- DO NOT delete local branches after merge (preserve history)

- Use descriptive names: `fix-chat-loading`, `feat-speed-insights`

- Push to origin/main but keep branch locally

- Local branches serve as backup

### Commit Standards

- Commit after each completed phase

- Write clear, descriptive messages in English

- Include documentation updates in commits

## Component Development

### Storybook Integration (if available)

Check if project has Storybook:

- `.storybook/` folder exists OR

- `package.json` has `@storybook/*` dependencies OR

- `package.json` has `storybook` scripts

**If Storybook exists in project:**

- ALWAYS create `.stories.tsx` for each component

- Test all states: default, loading, error, empty

- Verify visually before marking complete

- Consider accessibility

**If NO Storybook:**

- Skip stories creation

- Use alternative verification (tests, browser)

### Component Reuse Rule

- ALWAYS check existing components before creating new

- Prefer composition over duplication

- List similar components before creating new ones

Example:

```

❌ DON'T: Create new button from scratch

✅ DO: Find and use existing Button component

```

## Asset Management

- Save all external assets locally in project

- Use descriptive names: `user-icon.svg`, `sparkles-white.png`

- Store in appropriate directories: `public/icons/`

- Update paths to local references

- Add new files to Git

## AI Prompts for Graphics

### Technical Requirements in Prompts

- **ALWAYS include technical requirements** in AI prompts for graphics generation

- When creating prompts for image generation, include ALL technical details that affect the final result:

  - Exact dimensions (width x height in pixels)

  - Format requirements (PNG with transparency, tileable, etc.)

  - Color specifications (hex codes, color palette)

  - Perspective/view angle (top-down, side view, isometric)

  - Style requirements (realistic, cartoonish, post-apocalyptic)

  - Technical constraints (seamless/tileable, transparent background, etc.)

  - Use case context (how the image will be used in the game)

- **Never create incomplete prompts** - every prompt must be ready to copy-paste directly into AI tools

- If you notice technical requirements that should be in a prompt but aren't, add them immediately

- Examples of technical details to include:

  - Tileable/seamless requirements for textures

  - Transparency needs (alpha channel)

  - Rotation/orientation requirements

  - Size constraints for game performance

  - Color consistency with game palette

  - Animation frame requirements (if sprite sheet)

## Security

- NEVER modify security implementations without explicit user request

- Preserve all security patterns and validation

- Do not change webhook URLs or API endpoints without consent

- Maintain double validation for critical data

## Refactoring

### Refactor-As-You-Go

- Refactor immediately after completing task

- Keep files under 500 lines

- Use nested structure for large modules

- Split large files into smaller components

- Balance with time constraints

## Key Principles

**Remember:**

- **Quality over speed** - Solid foundations enable sustainable velocity

- **Plan first, code second** - No immediate coding without approval

- **Documentation is investment** - Increases value over time

- **Force scanning** - Show reasoning, don't guess

- **Reuse components** - Check design system first

- **You (engineer) × AI = 3x capability** - This is augmented engineering

This is AI-augmented engineering, not AI-vibe-led engineering

